<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Mosaic Fit</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ff4757">
    
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="icon" type="image/png" href="icon.png">

    <style>
        :root {
            --bg-color: #f0f2f5; 
            --grid-bg: #dfe4ea;
            --text-color: #2f3542;
            --primary: #3742fa;
            --accent: #ff4757;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.1s linear;
        }

        /* UI LAYERS */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20;
        }

        .active-layer { pointer-events: auto; }
        .hidden { display: none !important; pointer-events: none !important; }

        #start-screen { background: var(--accent); z-index: 300; }
        #main-menu { background: rgba(255,255,255,0.96); backdrop-filter: blur(20px); z-index: 200; }
        #death-screen { background: var(--accent); z-index: 250; }
        #abandon-modal { background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); z-index: 400; }

        .menu-container {
            padding: 30px 40px; border-radius: 30px;
            text-align: center; display: flex; flex-direction: column; align-items: center; gap: 20px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.15);
            max-width: 95%; max-height: 98vh; width: 400px;
            overflow-y: auto; overflow-x: hidden; box-sizing: border-box; background: white;
        }

        .start-container {
            padding: 40px; text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 20px;
            width: 100%; pointer-events: auto;
        }

        .big-logo {
            width: 100px; height: 100px; background: white; border-radius: 24px; 
            color: var(--accent); font-weight: 900; font-size: 4.5rem; 
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
            animation: float 4s ease-in-out infinite; margin-bottom: 10px;
        }

        #username-input { 
            background: rgba(255,255,255,0.2); border: 3px solid rgba(255,255,255,0.4); 
            padding: 20px 30px; color: white; font-size: 24px; border-radius: 60px; outline: none; width: 280px; 
            text-align: center; font-weight: 800; letter-spacing: 1px; transition: 0.3s;
            pointer-events: auto; user-select: text; -webkit-user-select: text; 
        }
        #username-input:focus { background: rgba(255,255,255,0.3); border-color: white; transform: scale(1.05); }

        .logo-row { display: flex; gap: 10px; margin-bottom: 20px; }
        .logo-block {
            width: 45px; height: 45px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: 900; font-size: 1.6rem;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1); animation: float 3s ease-in-out infinite;
        }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }

        .online-lb { 
            width: 100%; background: rgba(0,0,0,0.04); 
            border-radius: 24px; padding: 20px; border: 2px solid rgba(0,0,0,0.05); 
            margin-bottom: 20px; box-sizing: border-box; min-height: 250px;
            display: flex; flex-direction: column;
        }
        .dark-lb { background: rgba(0,0,0,0.2); border: 2px solid rgba(255,255,255,0.2); color: white; }
        
        .lb-header { text-align: center; font-size: 16px; letter-spacing: 2px; font-weight: 900; margin-bottom: 15px; opacity: 0.7; text-transform: uppercase; }
        .lb-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
        .lb-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; font-size: 18px; border-bottom: 2px solid rgba(0,0,0,0.06); }
        .dark-lb .lb-row { border-bottom: 2px solid rgba(255,255,255,0.15); }
        .lb-row:last-child { border: none; }
        
        .lb-left { display: flex; align-items: center; gap: 10px; }
        .lb-rank {
            background: var(--accent); color: white; font-weight: 900; font-size: 14px;
            width: 28px; height: 28px; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(255, 71, 87, 0.3);
        }
        .dark-lb .lb-rank { background: white; color: var(--accent); }
        .lb-name { font-weight: 800; font-size: 16px; color: var(--text-color); letter-spacing: -0.5px; max-width: 140px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .dark-lb .lb-name { color: white; }
        .lb-score { font-weight: 900; color: var(--primary); font-size: 18px; }
        .dark-lb .lb-score { color: white; }

        .btn {
            border: none; padding: 20px 60px; font-size: 1.5rem; border-radius: 18px;
            cursor: pointer; font-weight: 900; transition: transform 0.1s;
            box-shadow: 0 12px 30px rgba(0,0,0,0.2); text-transform: uppercase; letter-spacing: 1px;
            pointer-events: auto; display: block;
        }
        .btn:hover { transform: translateY(-3px); }
        .btn:active { transform: scale(0.96); }
        .btn-accent { background: var(--accent); color: white; } 
        .btn-white { background: white; color: var(--accent); }

        .btn-install {
            background: rgba(255,255,255,0.2); color: white; padding: 15px 30px; font-size: 1rem; 
            display: flex; align-items: center; gap: 10px; margin-top: 10px; border: 1px solid rgba(255,255,255,0.4); box-shadow: none;
        }

        .header {
            position: absolute; top: 30px; width: 90%; max-width: 500px;
            display: flex; justify-content: space-between; align-items: center;
            pointer-events: none; z-index: 5;
        }
        
        .mini-logo {
            width: 55px; height: 55px; background: var(--accent);
            border-radius: 14px; color: white; font-weight: 900; font-size: 2rem;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 6px 18px rgba(255, 71, 87, 0.4);
            animation: float 4s ease-in-out infinite; pointer-events: auto; cursor: pointer;
        }
        .score-box {
            background: white; padding: 12px 35px; border-radius: 35px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            font-weight: 800; font-size: 1.8rem; color: var(--primary);
            transition: transform 0.1s; min-width: 80px; text-align: center;
        }
        .score-pop { transform: scale(1.3); color: var(--accent); }
        
        .header-icon-btn {
            width: 55px; height: 55px; background: white; border-radius: 14px;
            border: none; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 6px 18px rgba(0,0,0,0.1); cursor: pointer; 
            color: var(--text-color); pointer-events: auto; transition: 0.2s;
        }
        .header-icon-btn:active { transform: scale(0.9); }
        .header-icon-btn.disabled { opacity: 0.5; pointer-events: none; filter: grayscale(100%); }

        /* Install Modal */
        #install-modal {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: flex-end; justify-content: center;
            background: rgba(0,0,0,0.4); z-index: 500; pointer-events: auto;
            backdrop-filter: blur(4px); opacity: 0; transition: opacity 0.5s;
        }
        .install-card {
            background: white; width: 90%; max-width: 400px;
            border-radius: 24px; padding: 30px; margin-bottom: 30px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transform: translateY(100px); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #install-modal.active { opacity: 1; }
        #install-modal.active .install-card { transform: translateY(0); }
        .install-title { font-size: 22px; font-weight: 900; color: var(--accent); margin-bottom: 10px; }
        .install-text { font-size: 16px; color: #555; margin-bottom: 20px; line-height: 1.5; }
        .ios-instruction { display: flex; align-items: center; justify-content: center; gap: 8px; font-weight: bold; color: #333; margin: 10px 0; }
        .close-link { display: block; margin-top: 15px; color: #999; font-size: 14px; text-decoration: none; cursor: pointer; }

        canvas {
            background: white; border-radius: 20px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.08);
            cursor: grab; max-width: 95vw;
            touch-action: none;
        }
        canvas:active { cursor: grabbing; }

        .death-title { font-size: 3.5rem; color: white; font-weight: 900; margin: 0 0 10px 0; text-shadow: 0 5px 0 rgba(0,0,0,0.2); }
        .death-score { font-size: 2rem; color: rgba(255,255,255,0.95); margin-bottom: 30px; font-weight: 700; }

        @media (max-width: 500px) {
            .menu-container { padding: 30px 20px; width: 95%; }
            .lb-row { font-size: 16px; }
            .header { top: 20px; }
            .btn { font-size: 1.3rem; padding: 20px 50px; }
            .big-logo { width: 80px; height: 80px; font-size: 3.5rem; }
            #username-input { width: 240px; font-size: 20px; }
            .score-box { font-size: 1.5rem; padding: 10px 25px; }
        }
    </style>
</head>
<body>

    <div id="start-screen" class="ui-layer active-layer">
        <div class="start-container">
            <div class="big-logo">M</div>
            <input type="text" id="username-input" placeholder="ENTER USERNAME" maxlength="12">
            <button class="btn btn-white" style="margin-top: 10px; color: var(--accent);" onclick="enterMainMenu()">ENTER</button>
            <button class="btn btn-install" id="homeBtn" style="display:none; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.4); margin-top:15px; font-size:1rem; padding:15px 30px;" onclick="triggerInstall()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right:10px;">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
                ADD TO HOME
            </button>
        </div>
    </div>

    <div id="main-menu" class="ui-layer hidden">
        <div class="menu-container">
            <div class="logo-row">
                <div class="logo-block" style="background:#ff6b6b; animation-delay:0s">M</div>
                <div class="logo-block" style="background:#feca57; animation-delay:0.1s">O</div>
                <div class="logo-block" style="background:#1dd1a1; animation-delay:0.2s">S</div>
                <div class="logo-block" style="background:#54a0ff; animation-delay:0.3s">A</div>
                <div class="logo-block" style="background:#5f27cd; animation-delay:0.4s">I</div>
                <div class="logo-block" style="background:#ff9ff3; animation-delay:0.5s">C</div>
            </div>
            <div class="online-lb">
                <div class="lb-header">BEST WORLDWIDE</div>
                <div id="main-lb-list" class="lb-content">
                    <div style="text-align:center; opacity:0.5;">Loading...</div>
                </div>
            </div>
            <button class="btn btn-accent" id="startBtn">PLAY</button>
        </div>
    </div>

    <div id="gameUI" class="ui-layer hidden">
        <div class="header">
            <div class="mini-logo" onclick="openAbandon()">M</div>
            <div class="score-box" id="scoreBox">0</div>
            <div style="width: 55px;"></div> 
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="death-screen" class="ui-layer hidden">
        <div class="menu-container" style="background: transparent; box-shadow: none; color: white;">
            <div class="death-title">GAME OVER</div>
            <div class="death-score">Final Score: <span id="finalScore">0</span></div>
            <div class="online-lb dark-lb">
                <div class="lb-header" style="color:white;">BEST WORLDWIDE</div>
                <div id="death-lb-list" class="lb-content">
                    <div style="text-align:center; opacity:0.5;">Loading...</div>
                </div>
            </div>
            <button class="btn btn-white" id="retryBtn">Play Again</button>
        </div>
    </div>

    <div id="abandon-modal" class="ui-layer hidden">
        <div class="menu-container">
            <div class="death-title" style="color:var(--text-color); font-size: 1.5rem; text-shadow:none;">Exit game?</div>
            <div style="font-size: 1.2rem; color: #555; font-weight: 600;">Your current progress will be lost.</div>
            <div style="display:flex; gap: 20px; margin-top:10px;">
                <button class="btn btn-white" style="color:var(--text-color); box-shadow: 0 5px 15px rgba(0,0,0,0.1); font-size:1.2rem; padding:15px 30px;" id="btn-stay">NO</button>
                <button class="btn btn-accent" style="font-size:1.2rem; padding:15px 30px;" id="btn-leave">YES</button>
            </div>
        </div>
    </div>

    <div id="install-modal" class="hidden">
        <div class="install-card">
            <div class="big-logo" style="width:60px; height:60px; font-size:2rem; margin: 0 auto 15px auto;">M</div>
            <div class="install-title">Install App</div>
            <div class="install-text" id="install-desc">Add Mosaic Fit to your home screen for the full screen experience.</div>
            <button id="android-install-btn" class="btn btn-accent" style="display:none; padding: 15px 30px; font-size: 1.2rem; margin: 0 auto;">Install Now</button>
            <div id="ios-install-hint" style="display:none;">
                <div class="ios-instruction">1. Tap <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#007aff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg> Share</div>
                <div class="ios-instruction">2. Select "Add to Home Screen"</div>
            </div>
            <a class="close-link" onclick="closeInstallModal()">Not Now</a>
        </div>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioSys = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            play: function(type) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                const now = this.ctx.currentTime;
                
                if (type === 'pop') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'snap') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'hold') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                } else if (type === 'clear') {
                    osc.type = 'sine';
                    const freqs = [523.25, 659.25, 783.99]; 
                    freqs.forEach((f, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g);
                        g.connect(this.ctx.destination);
                        o.frequency.value = f;
                        g.gain.setValueAtTime(0.05, now + i*0.05);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.5 + i*0.05);
                        o.start(now + i*0.05);
                        o.stop(now + 0.6 + i*0.05);
                    });
                } else if (type === 'gameover') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                }
            }
        };

        const DREAMLO_PUB = "697a67638f40bb1184c753d8";
        const DREAMLO_PRIV = "1T4aM6LFPEWY2ApIVDHBwA86dlEuPxH0WOrypoNivp-Q";
        let currentLeaderboard = [];
        let myName = "Player";
        let hasLoadedLB = false;

        async function fetchLeaderboard() {
            const dreamloURL = `http://dreamlo.com/lb/${DREAMLO_PUB}/json`;
            const render = (entries) => { hasLoadedLB = true; currentLeaderboard = entries; updateOnlineLB(entries); };
            const parseData = (text) => {
                try {
                    const data = JSON.parse(text);
                    let entries = [];
                    if (data && data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                        entries = Array.isArray(data.dreamlo.leaderboard.entry) ? data.dreamlo.leaderboard.entry : [data.dreamlo.leaderboard.entry];
                    }
                    return entries.map(e => ({ name: e.name, score: parseInt(e.score) }));
                } catch(e) { return null; }
            };

            try {
                const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(dreamloURL)}`;
                const response = await fetch(proxyUrl);
                const text = await response.text();
                const scores = parseData(text);
                if (scores) { render(scores); return; }
            } catch (e) {}
            
            if(hasLoadedLB) updateOnlineLB(currentLeaderboard);
        }

        setInterval(fetchLeaderboard, 5000); 
        fetchLeaderboard();

        function submitScore(name, score) {
            if(score > 0) {
                const cleanName = name.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 12) || "Guest";
                currentLeaderboard.push({ name: cleanName, score: score });
                currentLeaderboard.sort((a,b) => b.score - a.score);
                hasLoadedLB = true; 
                updateOnlineLB(currentLeaderboard);
                const targetUrl = `http://dreamlo.com/lb/${DREAMLO_PRIV}/add/${cleanName}/${score}`;
                const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(targetUrl)}`;
                fetch(proxyUrl).catch(e => console.log("Submit Error"));
            }
        }

        function updateOnlineLB(entries) {
            entries.sort((a,b) => b.score - a.score);
            const html = entries.length > 0 ? entries.slice(0, 5).map((e, i) => `
                <div class="lb-row">
                    <div class="lb-left">
                        <div class="lb-rank">#${i+1}</div>
                        <div class="lb-name">${e.name}</div>
                    </div>
                    <div class="lb-score">${e.score}</div>
                </div>
            `).join('') : '<div style="text-align:center; opacity:0.5;">No Scores Yet</div>';
            
            const mainList = document.getElementById('main-lb-list');
            const deathList = document.getElementById('death-lb-list');
            if(mainList) mainList.innerHTML = html;
            if(deathList) deathList.innerHTML = html;
        }

        let deferredPrompt;
        window.addEventListener('load', () => {
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
            const btn = document.getElementById('homeBtn');
            const userAgent = window.navigator.userAgent.toLowerCase();
            const isIOS = /iphone|ipad|ipod/.test(userAgent);

            if (!isStandalone) {
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    deferredPrompt = e;
                    btn.style.display = 'flex'; 
                });
                if (isIOS) btn.style.display = 'flex';
            }
        });

        window.triggerInstall = () => {
            const userAgent = window.navigator.userAgent.toLowerCase();
            const isIOS = /iphone|ipad|ipod/.test(userAgent);
            const modal = document.getElementById('install-modal');

            if (isIOS) {
                document.getElementById('ios-install-hint').style.display = 'block';
                modal.classList.remove('hidden');
                setTimeout(() => modal.classList.add('active'), 10);
            } else if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then(() => { deferredPrompt = null; });
            } else {
                alert("Use your browser's menu to Install App or Add to Home Screen.");
            }
        };

        window.closeInstallModal = () => {
            const modal = document.getElementById('install-modal');
            modal.classList.remove('active');
            setTimeout(() => modal.classList.add('hidden'), 500);
            localStorage.setItem('installPromptDismissed', 'true');
        };

        window.enterMainMenu = () => {
            AudioSys.init(); 
            const input = document.getElementById('username-input');
            const val = input.value.trim();
            if (val) myName = val;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('active-layer');
            document.getElementById('main-menu').classList.remove('hidden');
            document.getElementById('main-menu').classList.add('active-layer');
        };

        window.openAbandon = () => {
            if(window.gameInstance) window.gameInstance.requestAbandon();
        };

        const GRID_SIZE = 9; 
        const MIN_MATCH = 4; 
        const COLORS = ['#ff6b6b', '#feca57', '#1dd1a1', '#54a0ff', '#5f27cd', '#ff9ff3', '#48dbfb'];
        const PASTEL_COLORS = ['#ffcccc', '#fff5cc', '#ccf5e5', '#cce5ff', '#decceb', '#fccef5', '#ccf9ff'];

        const SHAPES = [
            [[0,0]], 
            [[0,0], [1,0]], [[0,0], [0,1]],
            [[0,0], [1,0], [2,0]], [[0,0], [0,1], [0,2]],
            [[0,0], [1,0], [2,0], [3,0]], [[0,0], [0,1], [0,2], [0,3]],
            [[0,0], [1,0], [0,1], [1,1]],
            [[0,0], [0,1], [0,2], [1,2]], [[0,0], [1,0], [2,0], [0,1]],
            [[0,0], [1,0], [2,0], [1,1]], [[1,0], [0,1], [1,1], [1,2]]
        ];

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.ui = {
                    menu: document.getElementById('main-menu'),
                    game: document.getElementById('gameUI'),
                    gameOver: document.getElementById('death-screen'),
                    scoreBox: document.getElementById('scoreBox'),
                    finalScore: document.getElementById('finalScore'),
                    abandon: document.getElementById('abandon-modal')
                };

                this.grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null));
                this.dockPieces = [];
                this.holdPiece = null; 
                this.particles = [];
                this.floatingTexts = [];
                this.placingBlocks = [];
                this.clearingCells = new Set();
                
                this.score = 0;
                this.dragPiece = null;
                this.isHoveringHold = false;
                
                this.dragOffset = {x: 0, y: 0};
                this.pointer = {x: 0, y: 0, isDown: false};

                this.isAnimating = false;
                this.isSpawning = false;
                this.isDying = false; 
                this.isPaused = false;
                this.shake = 0;
                this.flashAlpha = 0;
                
                this.bgRGB = [240, 242, 245]; 
                this.targetRGB = [240, 242, 245];

                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.setupInput();

                document.getElementById('startBtn').addEventListener('click', () => {
                    AudioSys.init(); 
                    this.startGame();
                });
                document.getElementById('retryBtn').addEventListener('click', () => this.restart());

                document.getElementById('btn-stay').addEventListener('click', () => {
                    this.isPaused = false;
                    this.ui.abandon.classList.add('hidden');
                    this.ui.abandon.classList.remove('active-layer');
                });

                document.getElementById('btn-leave').addEventListener('click', () => {
                    this.isPaused = false;
                    this.ui.abandon.classList.add('hidden');
                    this.ui.abandon.classList.remove('active-layer');
                    this.ui.game.classList.add('hidden');
                    this.ui.menu.classList.remove('hidden');
                    this.ui.menu.classList.add('active-layer');
                    this.targetRGB = [240, 242, 245];
                });

                this.loop();
            }

            requestAbandon() {
                if(this.state !== 'PLAY' || this.isDying) return;
                this.isPaused = true;
                this.ui.abandon.classList.remove('hidden');
                this.ui.abandon.classList.add('active-layer');
            }

            resize() {
                const maxWidth = Math.min(window.innerWidth * 0.95, 500);
                this.width = maxWidth;
                this.cellSize = (this.width - 40) / GRID_SIZE; 
                this.boardTop = 30;
                this.boardLeft = 20;

                const gridHeight = GRID_SIZE * this.cellSize;
                
                const holdSize = this.cellSize * 2.2; 
                this.holdZone = {
                    w: holdSize,
                    h: holdSize,
                    x: (this.width - holdSize) / 2, 
                    y: this.boardTop + gridHeight + 25 
                };

                this.dockY = this.holdZone.y + this.holdZone.h + 20; 
                this.dockHeight = this.cellSize * 5;

                this.height = this.dockY + this.cellSize * 3.5; 

                this.canvas.width = this.width * 2; 
                this.canvas.height = this.height * 2;
                this.canvas.style.width = `${this.width}px`;
                this.canvas.style.height = `${this.height}px`;
                this.ctx.scale(2, 2);
            }

            setupInput() {
                this.canvas.addEventListener('mousedown', e => this.handleStart(e));
                this.canvas.addEventListener('touchstart', e => this.handleStart(e), {passive: false});

                window.addEventListener('mousemove', e => this.handleMove(e));
                window.addEventListener('touchmove', e => this.handleMove(e), {passive: false});
                
                window.addEventListener('mouseup', e => this.handleEnd(e));
                window.addEventListener('touchend', e => this.handleEnd(e));
            }

            getPos(e) {
                const evt = e.touches && e.touches.length > 0 ? e.touches[0] : e;
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / 2 / rect.width; 
                const scaleY = this.canvas.height / 2 / rect.height;

                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            handleStart(e) {
                if (this.state !== 'PLAY' || this.isAnimating || this.isDying || this.isSpawning || this.isPaused) return;
                
                if (e.cancelable) e.preventDefault();
                
                const pos = this.getPos(e);
                this.pointer.x = pos.x;
                this.pointer.y = pos.y;
                this.pointer.isDown = true;

                if (this.holdPiece && 
                    pos.x > this.holdZone.x && pos.x < this.holdZone.x + this.holdZone.w &&
                    pos.y > this.holdZone.y && pos.y < this.holdZone.y + this.holdZone.h) {
                    
                    this.dragPiece = this.holdPiece;
                    this.dragPiece.isDragging = true;
                    this.dragOffset.x = -(this.dragPiece.w / 2);
                    this.dragOffset.y = -(this.dragPiece.h / 2);
                    if (e.touches) this.dragOffset.y -= 80;
                    
                    this.holdPiece = null;
                    AudioSys.play('pop');
                    return;
                }

                let bestPiece = null;
                const yToleranceUp = this.cellSize * 1.5; 
                const yToleranceDown = this.cellSize * 5.0; 
                const xTolerance = this.width / 3.5; 

                for (let piece of this.dockPieces) {
                    const centerX = piece.x + (piece.w * 0.55 / 2); 
                    const centerY = piece.y + (piece.h * 0.55 / 2);

                    const dx = Math.abs(pos.x - centerX);
                    const dy = pos.y - centerY; 

                    if (dx < xTolerance) {
                        if (dy > -yToleranceUp && dy < yToleranceDown) {
                            bestPiece = piece;
                        }
                    }
                }

                if (bestPiece) {
                    this.dragPiece = bestPiece;
                    bestPiece.isDragging = true;
                    
                    this.dragOffset.x = -(bestPiece.w / 2);
                    this.dragOffset.y = -(bestPiece.h / 2);
                    
                    if (e.touches) {
                        this.dragOffset.y -= 100; 
                    }
                    AudioSys.play('pop');
                }
            }

            handleMove(e) {
                if (!this.pointer.isDown || !this.dragPiece) return;
                if (e.cancelable) e.preventDefault();

                const pos = this.getPos(e);
                this.pointer.x = pos.x;
                this.pointer.y = pos.y;

                this.dragPiece.x = pos.x + this.dragOffset.x;
                this.dragPiece.y = pos.y + this.dragOffset.y;

                const centerPx = this.dragPiece.x + this.dragPiece.w/2;
                const centerPy = this.dragPiece.y + this.dragPiece.h/2;
                this.isHoveringHold = (centerPx > this.holdZone.x && centerPx < this.holdZone.x + this.holdZone.w &&
                                     centerPy > this.holdZone.y && centerPy < this.holdZone.y + this.holdZone.h);
            }

            handleEnd(e) {
                if (!this.pointer.isDown) return;
                this.pointer.isDown = false;
                this.isHoveringHold = false;

                if (this.dragPiece) {
                    const centerPx = this.dragPiece.x + this.dragPiece.w/2;
                    const centerPy = this.dragPiece.y + this.dragPiece.h/2;

                    // CHECK HOLD ZONE DROP
                    if (centerPx > this.holdZone.x && centerPx < this.holdZone.x + this.holdZone.w &&
                        centerPy > this.holdZone.y && centerPy < this.holdZone.y + this.holdZone.h) {
                        
                        this.swapHold();
                        this.dragPiece = null;
                        return;
                    }

                    const snap = this.getSnapCoordinates(this.dragPiece);
                    if (this.canPlace(this.dragPiece.shape, snap.gridX, snap.gridY)) {
                        this.placePiece(this.dragPiece, snap.gridX, snap.gridY);
                    } else {
                        this.dragPiece.isDragging = false;
                        if (!this.dockPieces.includes(this.dragPiece)) {
                            this.holdPiece = this.dragPiece;
                            this.holdPiece.x = this.holdZone.x + (this.holdZone.w - this.holdPiece.w*0.55)/2;
                            this.holdPiece.y = this.holdZone.y + (this.holdZone.h - this.holdPiece.h*0.55)/2;
                        } else {
                            this.animateReturn(this.dragPiece);
                        }
                    }
                    this.dragPiece = null;
                }
            }

            swapHold() {
                AudioSys.play('hold');
                const piece = this.dragPiece;
                piece.isDragging = false;
                piece.scale = 0.55; 

                if (this.holdPiece) {
                    const oldHold = this.holdPiece;
                    this.holdPiece = piece;
                    
                    if (this.dockPieces.includes(piece)) {
                        const idx = this.dockPieces.indexOf(piece);
                        oldHold.x = piece.baseX;
                        oldHold.y = piece.baseY;
                        oldHold.baseX = piece.baseX;
                        oldHold.baseY = piece.baseY;
                        oldHold.slotX = piece.slotX;
                        oldHold.slotY = piece.slotY;
                        oldHold.scale = 0.55;
                        this.dockPieces[idx] = oldHold;
                    }
                } else {
                    this.holdPiece = piece;
                    const idx = this.dockPieces.indexOf(piece);
                    if (idx > -1) this.dockPieces.splice(idx, 1);
                }

                this.holdPiece.x = this.holdZone.x + (this.holdZone.w - this.holdPiece.w*0.55)/2;
                this.holdPiece.y = this.holdZone.y + (this.holdZone.h - this.holdPiece.h*0.55)/2;

                if (this.dockPieces.length === 0) {
                    setTimeout(() => {
                        if (this.dockPieces.length === 0) this.spawnPieces();
                    }, 200);
                }
            }

            getSnapCoordinates(piece) {
                let relX = piece.x - this.boardLeft;
                let relY = piece.y - this.boardTop;
                let gridX = Math.round(relX / this.cellSize);
                let gridY = Math.round(relY / this.cellSize);
                return { gridX, gridY };
            }

            animateReturn(piece) {
                const startX = piece.x;
                const startY = piece.y;
                const endX = piece.baseX;
                const endY = piece.baseY;
                let t = 0;
                
                const anim = () => {
                    t += 0.15;
                    if(t > 1) {
                        piece.x = endX;
                        piece.y = endY;
                        return;
                    }
                    const ease = 1 - Math.pow(1 - t, 3);
                    piece.x = startX + (endX - startX) * ease;
                    piece.y = startY + (endY - startY) * ease;
                    requestAnimationFrame(anim);
                };
                anim();
            }

            startGame() {
                this.ui.menu.classList.add('hidden');
                this.ui.menu.classList.remove('active-layer');
                this.ui.game.classList.remove('hidden');
                this.state = 'PLAY';
                this.restart();
            }

            restart() {
                this.grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null));
                this.dockPieces = [];
                this.holdPiece = null;
                this.score = 0;
                this.dragPiece = null;
                this.particles = [];
                this.floatingTexts = [];
                this.placingBlocks = [];
                this.clearingCells.clear();
                this.isDying = false;
                this.isSpawning = false;
                this.isHoveringHold = false;
                this.targetRGB = [240, 242, 245];
                this.ui.gameOver.classList.add('hidden');
                this.ui.gameOver.classList.remove('active-layer');
                this.updateScore(0);
                this.spawnPieces();
            }

            spawnPieces() {
                this.isSpawning = true;
                this.dockPieces = [];
                const slotWidth = this.width / 3;

                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const shapeDef = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                        const colorIdx = Math.floor(Math.random() * COLORS.length);
                        const color = COLORS[colorIdx];
                        
                        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                        shapeDef.forEach(p => { 
                            minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]);
                            minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]);
                        });
                        
                        const shapeW = (maxX - minX + 1) * this.cellSize;
                        const shapeH = (maxY - minY + 1) * this.cellSize;
                        const slotCenterX = (i * slotWidth) + (slotWidth / 2) + 15;
                        const visualW = shapeW * 0.55;
                        const visualH = shapeH * 0.55;
                        
                        let baseX = slotCenterX - (visualW / 2);
                        if (baseX < 15) baseX = 15;
                        if (baseX + visualW > this.width - 15) baseX = this.width - visualW - 15;
                        
                        const baseY = this.dockY + (this.cellSize * 1.5) - (visualH / 2);

                        this.dockPieces.push({
                            shape: shapeDef, color: color,
                            x: baseX, y: baseY,
                            baseX: baseX, baseY: baseY,
                            w: shapeW, h: shapeH, 
                            slotX: slotCenterX, slotY: this.dockY + (this.cellSize * 1.5), 
                            scale: 0, targetScale: 0.55, isDragging: false 
                        });

                        if(i === 2) {
                            setTimeout(() => {
                                this.isSpawning = false;
                                this.checkGameOver();
                            }, 200);
                        }
                    }, i * 200);
                }
            }

            updateScore(pointsToAdd = 0) {
                this.score += pointsToAdd;
                this.ui.scoreBox.innerText = this.score;
                if(pointsToAdd > 0) {
                    this.ui.scoreBox.classList.remove('score-pop');
                    void this.ui.scoreBox.offsetWidth; 
                    this.ui.scoreBox.classList.add('score-pop');
                }
                const level = Math.floor(this.score / 100);
                if (level > 0) {
                    const idx = (level - 1) % PASTEL_COLORS.length;
                    const hex = PASTEL_COLORS[idx];
                    this.targetRGB = this.hexToRgb(hex);
                } else {
                    this.targetRGB = [240, 242, 245]; 
                }
            }

            hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return [r, g, b];
            }

            spawnFloatingText(text, x, y, color = '#2ed573', size = 40) {
                this.floatingTexts.push({ text: text, x: x, y: y, color: color, life: 1.0, velocityY: -2, size: size });
            }

            placePiece(piece, gridX, gridY) {
                AudioSys.play('snap');
                const targetX = this.boardLeft + (gridX) * this.cellSize; 
                const targetY = this.boardTop + (gridY) * this.cellSize;

                this.isAnimating = true; 
                let blockCount = piece.shape.length;
                let blocksLanded = 0;

                for (let i = 0; i < piece.shape.length; i++) {
                    const block = piece.shape[i];
                    
                    const dstX = this.boardLeft + (gridX + block[0]) * this.cellSize;
                    const dstY = this.boardTop + (gridY + block[1]) * this.cellSize;
                    
                    const startX = piece.x + (block[0] * this.cellSize);
                    const startY = piece.y + (block[1] * this.cellSize);

                    setTimeout(() => {
                        this.placingBlocks.push({
                            x: startX, y: startY, tx: dstX, ty: dstY, color: piece.color, progress: 0,
                            gridX: gridX + block[0], gridY: gridY + block[1],
                            onFinish: () => {
                                this.grid[gridY + block[1]][gridX + block[0]] = piece.color;
                                blocksLanded++;
                                if(blocksLanded === blockCount) this.finishPlacement();
                            }
                        });
                    }, i * 35);
                }
                
                if (this.dockPieces.includes(piece)) {
                    this.dockPieces = this.dockPieces.filter(p => p.slotX !== piece.slotX); 
                }
                if (this.holdPiece === piece) {
                    this.holdPiece = null;
                }
            }

            finishPlacement() {
                this.updateScore(10);
                this.checkMatches();
            }

            checkMatches() {
                let cellsToClear = new Set(); 
                let rowsCleared = 0;
                let colsCleared = 0;

                for (let y = 0; y < GRID_SIZE; y++) {
                    const row = this.grid[y];
                    if (row.every(cell => cell !== null)) {
                        let matchLen = 1;
                        for (let x = 1; x <= GRID_SIZE; x++) {
                            let prev = this.grid[y][x-1];
                            let curr = (x < GRID_SIZE) ? this.grid[y][x] : null;
                            if (prev && curr === prev) matchLen++;
                            else {
                                if (matchLen >= MIN_MATCH) {
                                    for (let k = 0; k < matchLen; k++) cellsToClear.add(`${x-1-k},${y}`);
                                }
                                matchLen = 1;
                            }
                        }
                        rowsCleared++;
                    }
                }

                for (let x = 0; x < GRID_SIZE; x++) {
                    let isColFull = true;
                    for(let y=0; y<GRID_SIZE; y++) if(this.grid[y][x] === null) { isColFull = false; break; }
                    if (isColFull) {
                        let matchLen = 1;
                        for (let y = 1; y <= GRID_SIZE; y++) {
                            let prev = this.grid[y-1][x];
                            let curr = (y < GRID_SIZE) ? this.grid[y][x] : null;
                            if (prev && curr === prev) matchLen++;
                            else {
                                if (matchLen >= MIN_MATCH) {
                                    for (let k = 0; k < matchLen; k++) cellsToClear.add(`${x},${y-1-k}`);
                                }
                                matchLen = 1;
                            }
                        }
                        colsCleared++;
                    }
                }

                if (cellsToClear.size > 0) {
                    AudioSys.play('clear');
                    this.isAnimating = true;
                    let finalClears = new Set();
                    cellsToClear.forEach(key => {
                        let [sx, sy] = key.split(',').map(Number);
                        let scolor = this.grid[sy][sx];
                        let queue = [{x: sx, y: sy}];
                        while(queue.length > 0) {
                            let {x, y} = queue.pop();
                            let k = `${x},${y}`;
                            if(finalClears.has(k)) continue;
                            finalClears.add(k);
                            const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                            dirs.forEach(d => {
                                let nx = x + d[0], ny = y + d[1];
                                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                                    if(this.grid[ny][nx] === scolor && !finalClears.has(`${nx},${ny}`)) queue.push({x: nx, y: ny});
                                }
                            });
                        }
                    });

                    this.clearingCells = finalClears;
                    
                    const totalLines = rowsCleared + colsCleared;
                    
                    // --- REWARDING COMBO LOGIC ---
                    if (totalLines > 0) {
                        let text = "";
                        let size = 50;
                        let color = "#ff4757"; // Default Red accent
                        
                        if (totalLines === 2) { text = "DOUBLE!"; size = 60; color = "#ffa502"; }
                        else if (totalLines === 3) { text = "TRIPLE!"; size = 70; color = "#ff6348"; }
                        else if (totalLines === 4) { text = "MEGA!"; size = 80; color = "#2ed573"; }
                        else if (totalLines >= 5) { text = "INSANE!"; size = 90; color = "#e056fd"; }
                        else if (totalLines === 1 && finalClears.size > 12) { text = "BIG CLEAR!"; size = 50; color = "#1e90ff"; }

                        // Trigger big center text
                        if (text) {
                            setTimeout(() => this.spawnFloatingText(text, this.width/2, this.height/2 - 80, color, size), 100);
                            this.shake = 8 + (totalLines * 4); // Bigger shake for bigger combos
                        }
                    }

                    setTimeout(() => this.processClears(finalClears, totalLines), 250);
                } else {
                    this.isAnimating = false;
                    if (this.dockPieces.length === 0) this.spawnPieces();
                    else this.checkGameOver();
                }
            }

            processClears(cellsSet, multiplier) {
                let count = 0;
                // Base shake is smaller, big shakes handled in checkMatches
                if(this.shake < 5) this.shake = 6 + Math.min(cellsSet.size, 10); 
                
                this.flashAlpha = 0.5;
                cellsSet.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    this.spawnParticles(x, y, this.grid[y][x]);
                    this.grid[y][x] = null;
                    count++;
                });
                
                // Score calculation with multiplier
                let mult = multiplier > 0 ? multiplier : 1;
                let points = ((count * 20) + (count - 4) * 30) * mult;
                
                this.updateScore(points);
                
                // Spawn Floating Score (Gold color, large size)
                this.spawnFloatingText(`+${points}`, this.width/2, this.height/2, '#f1c40f', 50);
                
                this.clearingCells.clear();
                setTimeout(() => {
                    this.isAnimating = false;
                    if (this.dockPieces.length === 0) this.spawnPieces();
                    else this.checkGameOver();
                }, 300);
            }

            spawnParticles(gx, gy, color) {
                const px = this.boardLeft + gx * this.cellSize;
                const py = this.boardTop + gy * this.cellSize;
                for(let i=0; i<8; i++) {
                    this.particles.push({
                        x: px + this.cellSize/2, y: py + this.cellSize/2,
                        vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                        gravity: 0.5, rotation: Math.random() * Math.PI, rotSpeed: (Math.random() - 0.5) * 0.4,
                        size: this.cellSize * (0.3 + Math.random()*0.3), color: color, life: 1.0, decay: 0.02
                    });
                }
            }

            checkGameOver() {
                if (this.isAnimating || this.dockPieces.length === 0 || this.isDying || this.isSpawning) return;
                
                let canMove = false;
                
                for (let piece of this.dockPieces) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        for (let y = 0; y < GRID_SIZE; y++) {
                            if (this.canPlace(piece.shape, x, y)) { canMove = true; break; }
                        }
                        if (canMove) break;
                    }
                    if (canMove) break;
                }

                if (!canMove && this.holdPiece) {
                     for (let x = 0; x < GRID_SIZE; x++) {
                        for (let y = 0; y < GRID_SIZE; y++) {
                            if (this.canPlace(this.holdPiece.shape, x, y)) { canMove = true; break; }
                        }
                        if (canMove) break;
                    }
                }
                
                if (!canMove) {
                    if (this.holdPiece === null && this.dockPieces.length > 0) {
                        return; 
                    }
                    AudioSys.play('gameover');
                    this.startDeathAnimation();
                }
            }

            startDeathAnimation() {
                this.isDying = true;
                for (let y = 0; y < GRID_SIZE; y++) {
                    setTimeout(() => {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (this.grid[y][x]) {
                                this.spawnParticles(x, y, this.grid[y][x]);
                                this.grid[y][x] = null;
                            }
                        }
                        this.shake = 2; 
                    }, y * 100); 
                }
                setTimeout(() => {
                    this.ui.finalScore.innerText = this.score;
                    this.ui.gameOver.classList.remove('hidden');
                    this.ui.gameOver.classList.add('active-layer');
                    submitScore(myName, this.score);
                }, GRID_SIZE * 100 + 800);
            }

            canPlace(shape, gridX, gridY) {
                for (let block of shape) {
                    let bx = gridX + block[0];
                    let by = gridY + block[1];
                    if (bx < 0 || bx >= GRID_SIZE || by < 0 || by >= GRID_SIZE) return false;
                    if (this.grid[by][bx] !== null) return false;
                }
                return true;
            }

            draw() {
                this.bgRGB[0] += (this.targetRGB[0] - this.bgRGB[0]) * 0.02;
                this.bgRGB[1] += (this.targetRGB[1] - this.bgRGB[1]) * 0.02;
                this.bgRGB[2] += (this.targetRGB[2] - this.bgRGB[2]) * 0.02;
                const newColor = `rgb(${Math.round(this.bgRGB[0])}, ${Math.round(this.bgRGB[1])}, ${Math.round(this.bgRGB[2])})`;
                document.documentElement.style.setProperty('--bg-color', newColor);
                
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.width, this.height);

                if(this.shake > 0) {
                    const dx = (Math.random() - 0.5) * this.shake;
                    const dy = (Math.random() - 0.5) * this.shake;
                    this.ctx.translate(dx, dy);
                    this.shake *= 0.9;
                    if(this.shake < 0.5) this.shake = 0;
                }

                // Draw Grid
                this.ctx.fillStyle = '#dfe4ea';
                this.ctx.fillRect(this.boardLeft - 5, this.boardTop - 5, (GRID_SIZE * this.cellSize) + 10, (GRID_SIZE * this.cellSize) + 10);

                for (let x = 0; x < GRID_SIZE; x++) {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        let px = this.boardLeft + x * this.cellSize;
                        let py = this.boardTop + y * this.cellSize;
                        this.drawRoundedRect(px, py, this.cellSize, '#f1f2f6', false);
                        if (this.grid[y][x]) this.drawRoundedRect(px, py, this.cellSize, this.grid[y][x], true);
                    }
                }

                // --- DRAW LARGE CENTER HOLD ZONE ---
                if (this.holdZone) {
                    // Border Change on Hover
                    const borderColor = this.isHoveringHold ? 'var(--accent)' : 'white';
                    if (this.isHoveringHold) {
                        this.ctx.fillStyle = 'var(--accent)';
                        // Simulate border by filling slightly larger
                        this.drawRoundedRect(this.holdZone.x - 3, this.holdZone.y - 3, this.holdZone.w + 6, 'var(--accent)', true);
                    }

                    // Main Box
                    this.ctx.shadowColor = "rgba(0,0,0,0.1)";
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetY = 5;
                    this.drawRoundedRect(this.holdZone.x, this.holdZone.y, this.holdZone.w, 'white', true, false);
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowOffsetY = 0;

                    // Text
                    if(!this.holdPiece && !this.isHoveringHold) {
                        this.ctx.fillStyle = "rgba(0,0,0,0.15)";
                        this.ctx.font = "bold 14px sans-serif";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText("HOLD", this.holdZone.x + this.holdZone.w/2, this.holdZone.y + this.holdZone.h/2 + 5);
                    }

                    // GHOST PIECE ON HOVER
                    if (this.isHoveringHold && this.dragPiece) {
                        const cx = this.holdZone.x + this.holdZone.w/2;
                        const cy = this.holdZone.y + this.holdZone.h/2;
                        
                        const shapeW = this.dragPiece.w * 0.45; 
                        const shapeH = this.dragPiece.h * 0.45;
                        const startX = cx - shapeW/2;
                        const startY = cy - shapeH/2;

                        this.ctx.save();
                        this.ctx.globalAlpha = 0.4; // Ghost opacity
                        for (let block of this.dragPiece.shape) {
                            let bx = startX + (block[0] * this.cellSize * 0.45);
                            let by = startY + (block[1] * this.cellSize * 0.45);
                            this.drawRoundedRect(bx, by, this.cellSize * 0.45, this.dragPiece.color, true);
                        }
                        this.ctx.restore();
                    }

                    // ACTUAL HOLD PIECE
                    if (this.holdPiece) {
                        const cx = this.holdZone.x + this.holdZone.w/2;
                        const cy = this.holdZone.y + this.holdZone.h/2;
                        
                        const shapeW = this.holdPiece.w * 0.45; 
                        const shapeH = this.holdPiece.h * 0.45;
                        const startX = cx - shapeW/2;
                        const startY = cy - shapeH/2;

                        for (let block of this.holdPiece.shape) {
                            let bx = startX + (block[0] * this.cellSize * 0.45);
                            let by = startY + (block[1] * this.cellSize * 0.45);
                            this.drawRoundedRect(bx, by, this.cellSize * 0.45, this.holdPiece.color, true);
                        }
                    }
                }

                // Draw Placing Blocks
                for (let i = this.placingBlocks.length - 1; i >= 0; i--) {
                    let b = this.placingBlocks[i];
                    b.progress += 0.08; 
                    if(b.progress > 1) b.progress = 1;
                    const t = b.progress;
                    const ease = 1 - Math.pow(1 - t, 3);
                    let curX = b.x + (b.tx - b.x) * ease;
                    let curY = b.y + (b.ty - b.y) * ease;
                    this.drawRoundedRect(curX, curY, this.cellSize, b.color, true);
                    if(b.progress === 1) { b.onFinish(); this.placingBlocks.splice(i, 1); }
                }

                // Draw Clears
                if (this.clearingCells.size > 0) {
                    this.ctx.save();
                    this.clearingCells.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        const px = this.boardLeft + x * this.cellSize;
                        const py = this.boardTop + y * this.cellSize;
                        this.drawRoundedRect(px, py, this.cellSize, 'white', true, false, true); 
                    });
                    this.ctx.restore();
                }

                // Particles
                for(let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                    p.rotation += p.rotSpeed;
                    p.life -= p.decay; p.size *= 0.98;
                    if(p.life <= 0) this.particles.splice(i, 1);
                    else {
                        this.ctx.save();
                        this.ctx.globalAlpha = p.life;
                        this.ctx.translate(p.x, p.y);
                        this.ctx.rotate(p.rotation);
                        this.ctx.fillStyle = p.color;
                        this.ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                        this.ctx.restore();
                    }
                }

                // Dragging Piece Shadow & Piece
                if (this.dragPiece && !this.isAnimating) {
                    
                    // IF HOVERING HOLD: Draw Smaller and Centered under finger (or snapped)
                    let scale = this.isHoveringHold ? 0.45 : 1.0;
                    
                    this.ctx.save();
                    
                    // Shadow
                    if (!this.isHoveringHold) {
                        this.ctx.globalAlpha = 0.5;
                        this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        for (let block of this.dragPiece.shape) {
                            let bx = this.dragPiece.x + (block[0] * this.cellSize) + 5;
                            let by = this.dragPiece.y + (block[1] * this.cellSize) + 10;
                            this.drawRoundedRect(bx, by, this.cellSize, 'black', true, true);
                        }
                    }

                    this.ctx.globalAlpha = 1.0;

                    for (let block of this.dragPiece.shape) {
                        // If hovering hold, we offset to center the smaller piece
                        let bx, by;
                        if(this.isHoveringHold) {
                             bx = this.dragPiece.x + (block[0] * this.cellSize * scale);
                             by = this.dragPiece.y + (block[1] * this.cellSize * scale);
                        } else {
                             bx = this.dragPiece.x + (block[0] * this.cellSize);
                             by = this.dragPiece.y + (block[1] * this.cellSize);
                        }
                        this.drawRoundedRect(bx, by, this.cellSize * scale, this.dragPiece.color, true);
                    }
                    
                    // Grid Snap Ghost (Only if not holding)
                    if (!this.isHoveringHold) {
                        const snap = this.getSnapCoordinates(this.dragPiece);
                        if (this.canPlace(this.dragPiece.shape, snap.gridX, snap.gridY)) {
                            this.ctx.globalAlpha = 0.3;
                            for (let block of this.dragPiece.shape) {
                                let px = this.boardLeft + (snap.gridX + block[0]) * this.cellSize;
                                let py = this.boardTop + (snap.gridY + block[1]) * this.cellSize;
                                this.drawRoundedRect(px, py, this.cellSize, this.dragPiece.color, true);
                            }
                            this.ctx.globalAlpha = 1.0;
                        }
                    }
                    this.ctx.restore();
                }

                // Dock Pieces
                if (!this.isDying) {
                    for (let piece of this.dockPieces) {
                        if(piece.isDragging) continue;

                        if(!piece.isDragging && piece.scale < piece.targetScale) {
                            piece.scale += 0.05;
                            if(piece.scale > piece.targetScale) piece.scale = piece.targetScale;
                        }

                        let scale = piece.scale;
                        if(scale <= 0) continue;

                        for (let block of piece.shape) {
                            let bx = piece.x + (block[0] * this.cellSize * 0.55); 
                            let by = piece.y + (block[1] * this.cellSize * 0.55);
                            let s = this.cellSize * 0.55 * (piece.scale / 0.55);
                            this.drawRoundedRect(bx, by, s, piece.color, true);
                        }
                    }
                }

                this.ctx.restore(); 

                // Flash Effect
                if(this.flashAlpha > 0) {
                    this.ctx.fillStyle = `rgba(255,255,255,${this.flashAlpha})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.flashAlpha -= 0.05;
                }

                // Floating Texts
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    let t = this.floatingTexts[i];
                    t.y += t.velocityY; t.life -= 0.01;
                    if(t.life <= 0) this.floatingTexts.splice(i, 1);
                    else {
                        this.ctx.save();
                        this.ctx.globalAlpha = t.life;
                        this.ctx.fillStyle = t.color;
                        // DYNAMIC SIZE HERE
                        this.ctx.font = "900 " + t.size + "px 'Segoe UI'";
                        this.ctx.textAlign = "center";
                        this.ctx.shadowColor = "rgba(0,0,0,0.2)";
                        this.ctx.shadowBlur = 10;
                        this.ctx.fillText(t.text, t.x, t.y);
                        this.ctx.restore();
                    }
                }
            }

            drawRoundedRect(x, y, size, color, isFilled, isShadow=false, isFlash=false) {
                if(isFlash) {
                    this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    let s = size;
                    this.ctx.beginPath();
                    this.ctx.roundRect(x, y, s, s, 6);
                    this.ctx.fill();
                    return;
                }
                this.ctx.fillStyle = isShadow ? 'rgba(0,0,0,0.2)' : color;
                let radius = isFilled ? 6 : 4;
                let gap = (isFilled && !isShadow) ? 2 : 2;
                let s = size - gap*2;
                let finalX = x + gap;
                let finalY = y + gap;
                this.ctx.beginPath();
                this.ctx.roundRect(finalX, finalY, s, s, radius);
                this.ctx.fill();
            }

            loop() {
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        window.addEventListener('load', () => {
             window.gameInstance = new Game();
        });

    </script>
</body>
</html>
